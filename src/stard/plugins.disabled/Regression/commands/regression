#!perl
use strict;
use warnings;

use lib("./lib");
use lib("../../lib");
use stard_lib;
use stard_core;
use stard_map;
use stard_regression;

$| = 1;
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
#1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
#2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
#3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# StarMadeâ„¢ is a registered trademark of Schine GmbH (All Rights Reserved)*
# The makers of stard make no claim of ownership or relationship with the owners of StarMade

## regression
# This script includes the primary regression testing code for stard.
# This script is called to test the stard standard library's functions for 
# defects.

## setup environment
my $debug_home = '.';
my $stard_home = "$debug_home/../..";
my $stard_plugins = "$stard_home/plugins";


stard_setup_run_env($stard_home);
setup_core_env($stard_home);
stard_stdlib_set_debug(2);


my $player = $ARGV[0];


main(@ARGV);
exit(0);

#################################################

sub main {
	my $player = $_[0];
	my $test = $_[1];

	stard_broadcast("Regression requested...");

	if (!$test || $test eq 'full') {
		stard_broadcast("Running full suite");
		stard_core_reg($player);
		general_reg($player);
		player_reg($player);
		faction_reg($player);
		sector_reg($player);
		map_reg($player);
		plugin_reg($player);
	}
	elsif ($test eq "core") {
		stard_core_reg($player);
	}
	elsif ($test eq "general") {
		general_reg($player);
	}
	elsif ($test eq "player") {
		player_reg($player);
	}
	elsif ($test eq "faction") {
		faction_reg($player);
	}
	elsif ($test eq "sector") {
		sector_reg($player);
	}
	elsif ($test eq "map") {
		map_reg($player);
	}
	elsif ($test eq "plugin") {
		plugin_reg($player);
	}
	else {
		stard_pm($player, "Error, requested regression suite not found: $test");
	};
	stard_broadcast("All tests passed!");
}


## general_reg
# perform basic functionality regression tests for stard
# INPUT1: name of the player who requested the testing.
sub general_reg {
	my $player = $_[0];
	my $test;
	my $string;
	my $cmd_result;
	my $input;
	my $echo;


	if (!stard_broadcast("###Running General Tests###")) {
		print "Failed to broadcast message :(\n";
		exit 1;
	}

	# Check to make sure the stard_escape_chars function correctly escapes 
	# the given characters
	$test = "starmade_escape_chars - escape test";
	$input = "test\"'";
	$cmd_result = starmade_escape_chars($input);
	print "echo -n $cmd_result\n";
	$echo = `echo -n $cmd_result`;
	test_result($test, $echo eq "test\"");


	# Check to see if the stard_cmd function will correctly launch a command
	$test = "stard_cmd - basic command";
	$input = "/status";
	$cmd_result = stard_cmd($input);
	test_result($test, $cmd_result =~/SERVER, Players/, "'$input' outputs: '$cmd_result'");

	
	# Check to see if the stard_pm function returns ok with a normal pm.
	$test = "stard_pm - general";
	$input = "pm test";
	test_result($test, stard_pm($player, $input));


	# Check to see if the stard_pm command returns failure for a non-existant player.
	$test = "stard_pm - missing_player";
	$input = "pm test";
	test_result($test, !stard_pm('dWtaUw', $input));

	
	# Check to see if there are admins in the admins.txt file
	my @admins = @{stard_admin_list()};
	test_result($test, @admins, "no admins appear in admins.txt");


	# Check to see if the function stard_is_admin returns trueif given the name of 
	# an admin
	$test = "stard_admin_list - realAdmin";
	test_result($test, stard_is_admin($admins[0]), "admin_list:" . join(",", @admins));


	# Check to see if the function stard_is_admin returns false if given the name 
	# of a non-admin
	$test = "stard_admin_list - fakeAdmin";
	test_result($test, !stard_is_admin('dWtaUw'));


	# Check to see if the stard_location_add, and stard_loc_distance 
	# functions can do the math correctly.
	test_result("stard_location_add", stard_location_add("1 1 1", "1 1 1") eq "2 2 2", stard_location_add("1 1 1", "1 1 1") . "!= '2 2 2'");
	test_result("stard_loc_distance:1", stard_loc_distance("0 0 0", "0 0 1") == 1);
	test_result("stard_loc_distance:2", stard_loc_distance("0 0 0", "0 1 0") == 1);
	test_result("stard_loc_distance:3", stard_loc_distance("0 0 0", "1 0 0") == 1);
	test_result("stard_loc_distance:null", stard_loc_distance("0 0 0", "0 0 0") == 0);
	test_result("stard_loc_distance:dec1", stard_loc_distance("0 0 0", "0 0 0.1") == 0.1);
	test_result("stard_loc_distance:dec2", stard_loc_distance("0 0 0", "0 0.1 0") == 0.1);
	test_result("stard_loc_distance:dec3", stard_loc_distance("0 0 0", "0.1 0 0") == 0.1);
	stard_broadcast("\n\n");
	print "\n\n";
	
}

## player_reg
# Perform player oriented functionality regression tests for stard
# INPUT1: name of the player who requested the testing.
sub player_reg {
	my $player = $_[0];
	if (!stard_broadcast("###Running Player Tests###")) {
		print "failed to broadcast message :(\n";
		exit 1;
	}


	# Check to see if the stard_god_mode function returns true when used 
	# against a player that exists.
	test_result("god_mode active", stard_god_mode($player, 1));
	test_result("god_mode inactive", stard_god_mode($player, 0));

	# Check to see if the stard_god_mode function returns false when used
	# against a player that does not exist
	test_result("god_mode invalid", !stard_god_mode('msbr', 1));

	
	
	# Check to see if the stard_inviability_mode function returns true when 
	# used against a player that exists.
	test_result("invisibility_mode active", stard_invisibility_mode($player, 1));
	test_result("invisibility_mode inactive", stard_invisibility_mode($player, 0));


	# Check to see if the stard_inviability_mode function returns false when 
	# used against a player that exists.
	test_result("invisibility_mode invalid", !stard_invisibility_mode('msbr', 1));


	# Check to see that the function player_list returns results
	my %player_list = %{stard_player_list()};
	my %player_info1 = %{$player_list{$player}};
	test_result(
		"player_list",
		keys %player_info1
	);
	stard_broadcast("$player\'s data:");
	for my $field (keys %player_info1) {
		stard_broadcast("$field: $player_info1{$field}");
	};


	# Check to see that the function stard_player_info returns the same results 
	# about the player as stard_player_list
	my %player_info2 = %{stard_player_info($player)};
	test_result("stard_player_info", keys %player_info2);
	my $consistancy = 1;
	for my $field (keys %player_info1) {
		if ($player_info1{$field} ne $player_info1{$field}) {
			stard_broadcast("player_list and player_info data don't match!");
			stard_broadcast("$field: $player_info1{$field} != $player_info2{$field}");
			$consistancy = 0;
		}
	};
	test_result("stard_player_info,stard_player_list - consistancy", $consistancy);
	stard_broadcast("\n\n");


	# Check to see that the given functions return true when used against a player
	# that exists.
	test_result("stard_give_credits", stard_give_credits($player, 100));
	test_result("stard_give_item", stard_give_item($player, "Thruster", 1));
	test_result("stard_give_all_items", stard_give_all_items($player, -1));
	test_result("stard_set_spawn_player", stard_set_spawn_player($player));

	# Check to see that the given functions return false when used against a
	# player that does not exist.
	test_result("stard_give_credits: unknown player", !stard_give_credits('adfaddreh', 100));
	test_result("stard_give_item: unknown player", !stard_give_item('adfaddreh', "Thruster", 1));
	test_result("stard_set_spawn_player:unknown player", !stard_set_spawn_player('adfaddreh'));
	test_result("stard_give_all_items: unknown player", !stard_give_credits('adfaddreh', -1));

	# Check to see that if given an invalid item, stard_give_item returns 
	# false
	test_result("stard_give_item: unknown item", !stard_give_item($player, "Thrusterz", 1));
	print "\n\n";	
}

## faction_reg
# Perform faction oriented functionality regression tests for stard
# INPUT1: name of the player who requested the testing.
sub faction_reg {
	my $player = $_[0];
	my %factions_bid;
	my %factions_bname;
	my %player_info;
	my $faction = "Test Faction";
	if (!stard_broadcast("###Running Factions Tests###")) {
		print "failed to broadcast message :(\n";
		exit 1;
	}

	
	# Clear out all factions (so we are sure to have no conflicts
	%factions_bname = %{stard_faction_list_bname()};
	while ($factions_bname{$faction}) {
		if ($factions_bname{$faction}{id} > 0) {
			stard_faction_delete($factions_bname{$faction}{id});
			%factions_bname = %{stard_faction_list_bname()};
		}
	}


	# Check that stard_faction_list_bid() returns information on the pirate faction
	%factions_bid = %{stard_faction_list_bid()};
	test_result("stard_faction_list_bid", defined $factions_bid{'-1'}, "faction_ids:" . join(",", keys %factions_bid));
	test_result("stard_faction_list_bid - name", defined $factions_bid{'-1'}{name});
	test_result("stard_faction_list_bid - desc", defined $factions_bid{'-1'}{desc});
	test_result("stard_faction_list_bid - size", defined $factions_bid{'-1'}{size});
	test_result("stard_faction_list_bid - points", defined $factions_bid{'-1'}{points});


	# Check that stard_faction_list_bname() returns information on the pirate faction
	%factions_bname = %{stard_faction_list_bname()};
	test_result("stard_faction_list_bname", defined $factions_bname{Pirates});
	test_result("stard_faction_list_bname - id", defined $factions_bname{Pirates}{id});
	test_result("stard_faction_list_bname - desc", defined $factions_bname{Pirates}{desc});
	test_result("stard_faction_list_bname - size", defined $factions_bname{Pirates}{size});
	test_result("stard_faction_list_bname - points", defined $factions_bname{Pirates}{points});


	# Check that stard_faction_list_bname and stard_faction_list_bid are giving the same information
	test_result("stard_faction_list_bname - consistancy", $factions_bname{Pirates}{id} == -1);
	test_result("stard_faction_list_bid - consistancy", $factions_bid{-1}{name} eq "Pirates");


	# Check that stard_faction_create creates a faction
	test_result("stard_faction_create", stard_faction_create($faction, ''));
	%factions_bname = %{stard_faction_list_bname()};
	test_result("stard_faction_create - validate", defined $factions_bname{$faction});


	# Check that stard_faction_add_member adds a player to that faction
	my $faction_id = $factions_bname{$faction}{id};
	test_result("stard_faction_add_member", stard_faction_add_member($player, $faction_id));
	%player_info = %{stard_player_info($player)};
	test_result("stard_faction_add_member - validate", $player_info{faction} == $faction_id);


	# Check that stard_faction_list_members mentions the player we just added
	my %members = %{stard_faction_list_members($faction_id)};
	test_result("stard_faction_list_members", defined $members{$player});


	# Check to see if faction_del_member removes the player from the faction
	test_result("stard_faction_del_member", stard_faction_del_member($player, $faction_id));
	%player_info = %{stard_player_info($player)};
	test_result("stard_faction_del_member - validate", ! defined $player_info{faction});


	# Check if stard_faction_delete deletes the faction
	test_result("stard_faction_delete", stard_faction_delete($faction_id));
	%factions_bname = %{stard_faction_list_bname()};
	test_result("stard_faction_delete - validate", !(defined $factions_bname{$faction}));
	stard_broadcast("\n\n");
	print "\n\n";
}

## sector_reg
# Perform sector oriented functionality regression tests for stard
# INPUT1: name of the player who requested the testing.
sub sector_reg {
	my $player = $_[0];	
	my %player_info;

	my $spawn = "2 2 2";
	my $sector1 = "5 5 5";

	if (!stard_broadcast("###Running Sector Tests###")) {
		print "failed to broadcast message :(\n";
		exit 1;
	}

	# Check that stard_change_section_for moves the player too the spawn sector
	stard_change_sector_for($player, $spawn);
	%player_info = %{stard_player_info($player)};
	test_result("stard_change_sector_for - spawn", $player_info{sector} eq $spawn);
	# we sleep as StarMade will not allow the player to be moved too often
	sleep 5;


	# Check that we could move the player to annother sector with stard_change_sector_for
	test_result("stard_change_sector", stard_change_sector_for($player, $sector1));
	%player_info = %{stard_player_info($player)};
	test_result("stard_change_sector_for - validate", $player_info{sector} eq $sector1);


	# Check that we can spawn a mob with stard_spawn_entity
	my $ship_name = "spawn_test";
	my $blueprint = "Isanth Type-Zero Mc";
	test_result("stard_spawn_entity", stard_spawn_entity($blueprint, $ship_name, $sector1, -1, 'false' ));
	my %search = %{stard_search($ship_name)};
	my $validate = keys %search;
	test_result("stard_search/stard_spawn_entity", $validate >= 1);
	%search = %{stard_sector_info($sector1)};
	$validate = join(" ", keys %{$search{entity}});
	test_result("stard_sector_info/stard_spawn_entity", $search{entity}{"ENTITY_SHIP_$ship_name"}, $validate);

	
	# Check that we can despawn the mob with stard_despawn_all
	test_result("stard_despawn_all", stard_despawn_all($ship_name, 'all', 'true'));
	%search = %{stard_search($ship_name)};
	$validate = keys %search;
	test_result("stard_despawn_all - validate", $validate <= 0);


	# Check that we can spawn annother mob
	$ship_name = "spawn_test2";
	stard_spawn_entity($blueprint, $ship_name, $sector1, -1, 'false');


	# Check that we can despawn the mod with stard_despawn_sector 
	test_result("stard_despawn_sector", stard_despawn_sector($ship_name, 'all', 'true', $sector1));
	%search = %{stard_search($ship_name)};
	$validate = keys %search;
	test_result("stard_despawn_all - validate", $validate <= 0);

	
	# Check that running stard_spawn_entity with an invalid blueprint returns false
	$ship_name = "spawn_test3";
	$blueprint = "goblygook";
	test_result("stard_spawn_entity - invalid blueprint", !stard_spawn_entity($blueprint, $ship_name, $sector1, -1, 'false'));


	# Check that stard_sector_chmod can set a sector to protected
	test_result("stard_sector_chmod - set protected", stard_sector_chmod($sector1, "add", "protected"));
	my %sector_info = %{stard_sector_info($sector1)};
	test_result("stard_sector_chmod/stard_sector_info validation", $sector_info{general}{info}{protected});
	sleep 5;	


	# Check that we can remove the sector protection with stard_sector_chmod
	test_result("stard_sector_chmod - unset protected", stard_sector_chmod($sector1, "remove", "protected"));
	%sector_info = %{stard_sector_info($sector1)};
	test_result("stard_sector_chmod/stard_sector_info validation", !$sector_info{general}{info}{protected});


	stard_broadcast("\n\n");
	print "\n\n";

};

## map_reg
# Perform tests for the stard_map library
# INPUT1: name of the player who requested the testing.
sub map_reg {
	my $player = $_[0];

	my $map = "./files/Maps/test.map";
	my %map_config = %{stard_read_config($map)};
	my $blueprint = "Isanth Type-Zero Mc";
	my $sector = "8 0 8";
	
	my %sector_info;
	my @validate;

	if (!stard_broadcast("###Running Map Tests###")) {
		print "failed to broadcast message :(\n";
		exit 1;
	}


	# Check that we can clear the map locations of unite with stard_clean_map_area
	stard_spawn_entity($blueprint, "itsz", $sector, -1, 0 );
	test_result("stard_clean_map_area - full clean return ok", stard_clean_map_area(\%map_config, "full"));
	%sector_info = %{stard_sector_info($sector)};
	@validate = keys %{$sector_info{entity}};
	test_result("stard_clean_map_area - successfull clean", !@validate);


	# Check that we can deploy a map configuration
	test_result("stard_setup_map - return ok", stard_setup_map(\%map_config));
	%sector_info = %{stard_sector_info($sector)};
	test_result("stard_setup_map - object spawn", $sector_info{entity}{ENTITY_SHIP_test_station});
	test_result("stard_setup_map - defender spawn", %{stard_search("Isanth Type-Zero Bm")});


	# check that we can clean things back up.
	test_result("stard_clean_map_area - full clean return ok 2", stard_clean_map_area(\%map_config, "full"));

}

## stard_core_reg
# Run tests against the functions in the stard_core library
# INPUT1: player name
sub stard_core_reg {
	my $player = shift(@_);

	my $test_cmd;
	my $logfile;
	my $argfile;
	my $result;

	my @plugins = @{get_active_plugin_list()};
	test_result("stard_core - get_active_plugin_list", $#plugins);


	$result = get_exec_prefix("./files/execs/bash-script");
	test_result("stard_core - get_exec_prefix bash", $result =~/bash$/);
	test_result("stard_core - get_exec_prefix bash exec", -x $result);

	$result = get_exec_prefix("./files/execs/perl-script");
	test_result("stard_core - get_exec_prefix perl", $result =~/perl$/);
	test_result("stard_core - get_exec_prefix perl exec", -x $result);

	$result = get_exec_prefix("./files/execs/python-script");
	test_result("stard_core - get_exec_prefix perl", $result =~/python$/);
	test_result("stard_core - get_exec_prefix perl", -x $result);

	$result = get_exec_prefix("./files/execs/abs-path-script");
	test_result("stard_core - get_exec_prefix abs-path", !$result);


	### plugin_command tests
	$test_cmd = "test";
	$logfile = "$stard_home/log/plugins/Regression-log/cmd-$test_cmd.log";
	$argfile = "./tmp/commands/$test_cmd";
	unlink($argfile);
	unlink($logfile);
	plugin_command($test_cmd, 'arg1', 'arg2', 'arg3');
	sleep 2;
	test_result("stard_core - plugin_command args", ck_file_string($argfile, "$test_cmd 'arg1' 'arg2' 'arg3'\n"));
	test_result("stard_core - plugin_command logs", -e $logfile);


	### plugin_server_event tests
	$test_cmd = "test_event";
	$logfile = "$stard_home/log/plugins/Regression-log/event-$test_cmd.log";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	unlink($logfile);
	plugin_server_event($test_cmd, 'arg1', 'arg2', 'arg3');
	sleep 1;
	test_result("stard_core - plugin_server_event args", ck_file_string($argfile, "$test_cmd 'arg1' 'arg2' 'arg3'\n"));
	test_result("stard_core - plugin_server_event logs", -e $logfile);


	### server_messages tests
	$test_cmd = "playerSpawn";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER][SPAWN] SPAWNING NEW CHARACTER FOR PlS[Jeryia [Jeryia]*; id(3)(2)f(0)]\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd 1", ck_file_string($argfile, "$test_cmd 'Jeryia' 'Jeryia'\n"));
	
	$test_cmd = "playerSpawn";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER][SPAWN] SPAWNING NEW CHARACTER FOR PlS[Jeryia; id(3)(2)f(0)]\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd 2", ck_file_string($argfile, "$test_cmd 'Jeryia'\n"));

	$test_cmd = "playerLogin";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER][LOGIN] new client connected. given id: 2: description: Jeryia\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'Jeryia'\n"));

	$test_cmd = "playerLogout";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER][DISCONNECT] Client 'RegisteredClient: Jeryia (5) connected: true' HAS BEEN DISCONNECTED\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'Jeryia'\n"));

	$test_cmd = "playerDeath";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER] character PlayerCharacter[(ENTITY_PLAYERCHARACTER_Jeryia)(486)] has been deleted by Sector[487](8, 8, 8)\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'Jeryia' 'Sector[487](8, 8, 8)'\n"));

	$test_cmd = "playerDeath";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER] character PlayerCharacter[(ENTITY_PLAYERCHARACTER_Jeryia)(486)] has been deleted by Sector[487](8, 8, 8)\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'Jeryia' 'Sector[487](8, 8, 8)'\n"));

	$test_cmd = "playerLogout";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER] onLoggedOut starting for RegisteredClient: Jeryia (2) [Jeryia]connected: true\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'Jeryia' 'Jeryia'\n"));

	$test_cmd = "playerFaction";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER][ChannelRouter] Faction Changed by PlS[Jeryia ; id(3)(2)f(10041)] to 10041\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'Jeryia' '10041'\n"));

	$test_cmd = "playerFaction";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER][ChannelRouter] Faction Changed by PlS[Jeryia [Jeryia]*; id(3)(2)f(10041)] to 10041\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'Jeryia' '10041'\n"));

	$test_cmd = "playerUnFaction";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER][Faction] Sending removal of member Jeryia from Faction [id=10041, name=Test Faction, description=description goes here, size: 1; FP: 100]\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'Jeryia' '10041'\n"));

	$test_cmd = "entityUnFaction";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER] FACTION BLOCK REMOVED FROM SpaceStation[ENTITY_SPACESTATION_Ares Mining Outpost_1443893697034(310)]; resetting faction !!!!!!!!!!!!!!\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'ENTITY_SPACESTATION_Ares Mining Outpost_1443893697034'\n"));

	$test_cmd = "entityFaction";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER] received object faction change request 10038 for object SpaceStation[ENTITY_SPACESTATION_Ares Mining Outpost_1443893697034(310)]\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'ENTITY_SPACESTATION_Ares Mining Outpost_1443893697034' '10038'\n"));

	$test_cmd = "entityDestroyed";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER][SEGMENTCONTROLLER] PERMANENTLY DELETING ENTITY: ENTITY_SPACESTATION_Beta_base_1443297379.ent\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'SPACESTATION_Beta_base_1443297379'\n"));

	$test_cmd = "sectorChange";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER] PlayerCharacter[(ENTITY_PLAYERCHARACTER_Jeryia)(139)] has players attached. Doing Sector Change for PlS[Jeryia ; id(3)(1)f(10073)]: Sector[5](3, 8, 7) -> Sector[23](3, 8, 6)\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd", ck_file_string($argfile, "$test_cmd 'ENTITY_PLAYERCHARACTER_Jeryia' 'Jeryia' '3 8 7' '3 8 6'\n"));

	$test_cmd = "sectorChange";
	$argfile = "./tmp/serverEvents/$test_cmd";
	unlink($argfile);
	server_messages("[SERVER] Ship[UE Patrol Ship MKIV_1443985052059](299) has CHARACTER. Doing Sector Change for PlayerCharacter[(ENTITY_PLAYERCHARACTER_Jeryia)(272)]: Sector[330](5, 8, 4) -> Sector[344](5, 8, 5) ID 344\n");
	sleep 1;
	test_result("stard_core - server_messages $test_cmd 2", ck_file_string($argfile, "$test_cmd 'UE Patrol Ship MKIV_1443985052059' 'Jeryia' '5 8 4' '5 8 5'\n"));


	### chat_messages tests
	$test_cmd = "test";
	$argfile = "./tmp/commands/$test_cmd";
	unlink($argfile);
	chat_messages("[CHANNELROUTER] RECEIVED MESSAGE ON Server(0): [CHAT][sender=$player][receiverType=CHANNEL][receiver=all][message=!test a1 a2 a3 ' sd']");
	sleep 1;
	test_result("stard_core - chat_messages $test_cmd", ck_file_string($argfile, "$test_cmd '$player' 'a1' 'a2' 'a3' ' sd'\n"));
	
	
}


## plugin_reg
# run tests on all active plugins (who have a regression test)
# INPUT1: player name
sub plugin_reg {
	my $player = shift(@_);

	my @plugins = @{get_active_plugin_list()};
	foreach my $plugin (@plugins) {
		test_result("Plugin $plugin - Final Result", plugin_reg_launch($plugin, $player));
	}
}


## plugin_reg_launch
# Spawns off the regression tests for the given plugin (if it has one)
# INPUT1: plugin name
# OUTPUT: (boolean) sucess if plugin's regression came back ok
sub plugin_reg_launch {
	my $plugin = shift(@_);
	my $player = shift(@_);

	if ( ! -x "../$plugin/.regression") {
		return 1; 
	}


	stard_broadcast("###Running $plugin Plugin Tests###");

	my $pid = fork();
	if ($pid) {
		waitpid($pid, 0);
		if ( $? == 0) {
			return 1;
		}
		return 0;
	}
	else {
		# other plugins will always be one 
		# directory down from this one
		chdir("../$plugin") or die "could not chdir to '../$plugin'\n";
		my $exec = get_exec_prefix("./.regression");
		exec("$exec", "./.regression", $player);
		die "Failed to run ./regression for $plugin!\n";
	}
}


## ck_file_string
# check for a specific string in a file's contents
# INPUT1: file
# INPUT2: string
# OUTPUT: (boolean) true if string is found, false if not
sub ck_file_string {
	my $file = shift(@_);
	my $string = shift(@_);

	my $fh;
	if (!open($fh, "<", $file)) {
		warn "Failed to open file '$file': $!\n";
		stard_broadcast("Failed to open file '$file': $!\n");
		return 0;
	}
	while (<$fh>) {
		if ($_ =~/\Q$string\E/) {
			return 1;
		}
	}
	return 0;
}
